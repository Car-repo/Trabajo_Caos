# -*- coding: utf-8 -*-
"""
@author: Carlos
"""
import numpy as np

def rkv65(f,time,x0,step=1e-3,utol=(1e-12,1e-15),**kwargs):
    """
    f: funcion de signatura (x: array, t escalar)->(y: array).
    time: intervalo de la forma [0,T].
    x0: condicion inicial.
    step: paso inicial.
    utol: tupla de tolerancias absoluta y relativa (atol,rtol).
    dense: booleano. Generacion de interpoladores.
    event: funcion de signatura (x:array)-> bool.
    """
    
    # Runge-Kutta 6 & 5
    c = [0]*9
    c[1] =  .6e-1
    c[2] =  .9593333333333333333333333333333333333333e-1
    c[3] =  .1439
    c[4] =  .4973
    c[5] =  .9725
    c[6] =  .9995
    c[7] =  1.
    c[8] =  1.

    a2 = [.6e-1]

    a3 = [0]*2
    a3[0] =  .1923996296296296296296296296296296296296e-1
    a3[1] =  .7669337037037037037037037037037037037037e-1

    a4 = [0]*3
    a4[0] =  .35975e-1
    a4[2] =  .107925

    a5 = [0]*4
    a5[0] =  1.318683415233148260919747276431735612861
    a5[2] = -5.042058063628562225427761634715637693344
    a5[3] =  4.220674648395413964508014358283902080483

    a6 = [0]*5
    a6[0] = -41.87259166432751461803757780644346812905
    a6[2] =  159.4325621631374917700365669070346830453
    a6[3] = -122.1192135650100309202516203389242140663
    a6[4] =  5.531743066200053768252631238332999150076

    a7 = [0]*6
    a7[0] = -54.43015693531650433250642051294142461271
    a7[2] =  207.0672513650184644273657173866509835987
    a7[3] = -158.6108137845899991828742424365058599469
    a7[4] =  6.991816585950242321992597280791793907096
    a7[5] = -.1859723106220323397765171799549294623692e-1

    a8 = [0]*7
    a8[0] = -54.66374178728197680241215648050386959351
    a8[2] =  207.9528062553893734515824816699834244238
    a8[3] = -159.2889574744995071508959805871426654216
    a8[4] =  7.018743740796944434698170760964252490817
    a8[5] = -.1833878590504572306472782005141738268361e-1
    a8[6] = -.5119484997882099077875432497245168395840e-3

    a9 = [0]*8
    a9[0] =  .3438957868357036009278820124728322386520e-1
    a9[3] =  .2582624555633503404659558098586120858767
    a9[4] =  .4209371189673537150642551514069801967032
    a9[5] =  4.405396469669310170148836816197095664891
    a9[6] = -176.4831190242986576151740942499002125029
    a9[7] =  172.3641334014150730294022582711902413315

    b = np.asarray(a9+[0],dtype='float64')  
    bh = np.asarray([0]*9,dtype='float64') 
    bh[ 0] =  .4909967648382489730906854927971225836479e-1
    bh[ 3] =  .2251112229516524153401395320539875329485
    bh[ 4] =  .4694682253029562039431948525047387412553
    bh[ 5] =  .8065792249988867707634161808995217981443
    bh[ 7] = -.6071194891777959797672951465256217122488
    bh[ 8] =  .5686113944047569241147603178766138153594e-1
       
    # Interpolador
    c.append(0.5)
    a10 = [0]*9
    a10[0] =  .1652415901357280684383619367363197852645e-1
    a10[3] =  .3053128187514178931377105638345583032476
    a10[4] =  .2071200938201978848991082158995582390341
    a10[5] = -1.293879140655123187129665774327355723229
    a10[6] =  57.11988411588149149650780257779402737914
    a10[7] = -55.87979207510932290773937033203265749155
    a10[8] =  .2483002829776601348057855515823731483430e-1
    
    bi5 = np.zeros((10,6),dtype='float64')
    
    bi5[0,0] =  1.
    bi5[0,1] = -5.308169607103576297743491917539437544903
    bi5[0,2] =  10.18168044895868030520877351032733768603
    bi5[0,3] = -7.520036991611714828300683961994073691563
    bi5[0,4] =  .9340485368631160925057442706475838478288
    bi5[0,5] =  .7468671915770650884224462998058729264688
    
    bi5[3,1] =  6.272050253212501244827865529084399503479
    bi5[3,2] = -16.02618147467745958442607061022576892601
    bi5[3,3] =  12.84435632451961742214954703737612797249
    bi5[3,4] = -1.148794504476759027536609501260874665600
    bi5[3,5] = -1.683168143014549714548776645115271798480

    bi5[4,1] =  6.876491702846304590450466371720363234704
    bi5[4,2] = -24.63576726084633318864583120149461053641
    bi5[4,3] =  33.21078648379717088772133447477731248517
    bi5[4,4] = -17.49461528263643828092150992351036511970
    bi5[4,5] =  2.464041475806649706459795429914280132942

    bi5[5,1] = -35.54445171059960218765875699270358093032
    bi5[5,2] =  165.7016170190242105108446269288474846144
    bi5[5,3] = -385.4635395491142731464726480659809841649
    bi5[5,4] =  442.4324137015701845319394642134164121973
    bi5[5,5] = -182.7206429912112095385038492673822360516

    bi5[6,1] =  1918.654856698011449175045220651610014945
    bi5[6,2] = -9268.121508966042500195164712930044037430
    bi5[6,3] =  20858.33702877255011893787944928058522511
    bi5[6,4] = -22645.82767158481047968149020787687967272
    bi5[6,5] =  8960.474176055992754148556156624828257597

    bi5[7,1] = -1883.069802132718312960582779305006646556
    bi5[7,2] =  9101.025187200633795903395040749471730528
    bi5[7,3] = -20473.18855195953591834830509979123557878
    bi5[7,4] =  22209.76555125653413900516974418122400018
    bi5[7,5] = -8782.168250963498630570274647563263264047

    bi5[8,1] =  .1190247963512364356614756628348873476063
    bi5[8,2] = -.1250269670503937512118264468821359362429
    bi5[8,3] =  1.779956919394999075328101026471971070697
    bi5[8,4] = -4.660932123043762639666625363637083723091
    bi5[8,5] =  2.886977374347920879888875121212361241030

    bi5[9,1] = -8.
    bi5[9,2] =  32.
    bi5[9,3] = -40.
    bi5[9,4] =  16.
    
    
    time,x0 = np.asarray(time,dtype='float64'),np.asarray(x0,dtype='float64')
    h = step
    T = [time[0]]
    x = [x0]
    atol,rtol = utol
    
    min_factor = .625
    max_factor = 1.6
    
    t = T[-1]
    y = x[-1]
    F = np.zeros((10,len(y)),dtype='float64')
    
    if 'dense' not in kwargs:
        kwargs['dense'] = False
    if 'event' not in kwargs:
        kwargs['event'] = lambda y: False       
    if kwargs['dense']:
        bi5 = bi5.T
        interpolantes = [bi5]

    while t < time[1]:
        
        # Terminar si la posicion cumple una condicion
        if kwargs['event'](y):
            break
        
        if t + h > time[1]:
            h = time[1]-t
        
        # Bloque principal
        F[0] = f(y,t+h*c[0])
        F[1] = f(y+h*(a2@F[:1]), t+h*c[1])
        F[2] = f(y+h*(a3@F[:2]), t+h*c[2])
        F[3] = f(y+h*(a4@F[:3]), t+h*c[3])
        F[4] = f(y+h*(a5@F[:4]), t+h*c[4])
        F[5] = f(y+h*(a6@F[:5]), t+h*c[5])
        F[6] = f(y+h*(a7@F[:6]), t+h*c[6])
        F[7] = f(y+h*(a8@F[:7]), t+h*c[7])
        fsal = y+h*(a9@F[:8]) # Propiedad FSAL
        F[8] = f(fsal, t+h*c[8])

        ev = h*((b-bh)@F[:9])

        # Formula de error local
        norm1 = np.linalg.norm(y,2)
        norm2 = norm1 if len(x) < 2 else np.linalg.norm(x[-2],2)              
        tol = atol + rtol*max(norm1,norm2)
        err = np.linalg.norm(ev/tol,2)      

        if err <= 1:            
            if kwargs['dense']:
                F[9] = f(y+h*(a10@F[:9]), t+h*c[9])
                vector = F.copy()                            
                interpolantes.append((y,h,vector))
                
            x.append(fsal)
            y = x[-1]
            t += h
            T.append(t)
                
            if err == 0:
                h *= max_factor
            else:
                h *= min(max_factor,0.9*err**(-1/6))             
        else:
            h *= max(min_factor,0.9*err**(-1/6))
                
    result = {'x':np.asarray(x),'t':np.asarray(T)}
    if kwargs['dense']:
        result['dense'] = interpolantes

    return result


def eval_interpol(tspan,solution):
    """
    tspan: array ORDENADO de tiempos y contenido en el intervalo de definicion.
    solution: resultado de rkv65.
    """
    
    t,interpolants = solution['t'],solution['dense']
    tspan = np.asarray(tspan)  
    index = []
    j = 0
    
    # Agrupar tiempos segun los intervalos de t
    for time in t[1:-1]:
        while j < len(tspan) and tspan[j] < time:
            j += 1
        index.append(j)
        
    slices = np.split(tspan,index)
    
    bi5 = interpolants[0]
    interpolants = interpolants[1:]
    y = []
    
    # Interpolacion local
    for j in range(len(slices)):
        if len(slices[j]) > 0:
            x0,h,F = interpolants[j]
            rho = (slices[j]-t[j])/h
            coef = np.asarray([rho**u for u in range(1,7)]).T
            y.append(x0 + h*(coef@bi5)@F)
    
    return np.concatenate(y)
